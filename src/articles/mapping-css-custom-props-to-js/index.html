---
layout: article.html
highlightSyntax: true
title: "Mapping CSS Custom Properties to JavaScript"
date: "2019-06-09"
permalink: /articles/mapping-css-custom-props-to-js
meta:
  description: An exploration automating the process of accessing CSS Custom Properties in JavaScript
---

<p class="entry-intro">
  This idea was knocking around in my brain for a while. I wondered how I could make CSS custom properties available in JavaScript in an automatic and idiomatic way.
</p>
<p>
  In this post I’ll detail different ways to accomplish the goal. Including one approach I wanted to work that doesn’t and one that kinda works today, and might more in the future. Along the way I’ll describe the code, my thought process, and things I learned.
</p>
<p>
  Here’s a companion
  <a href="https://glitch.com/edit/#!/mapping-css-custom-props-to-js">Glitch project</a>
  with working code for each approach.
</p>

<h2 id="the-basic-approach">The Basic Approach</h2>
<p>
  Let’s start with the baseline approach to accessing CSS custom props
  in JavaScript. If you’re following along in the demo, this is the
  <a href="https://mapping-css-custom-props-to-js.glitch.me/basic/">“Basic”</a> example.
</p>
<p>
  There are two native JavaScript methods that do the heavy lifting.
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle"><code>window.getComputedStyle</code></a> and
  <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/getPropertyValue"><code>getPropertyValue</code></a>. We have a custom
  prop <code>--color-accent</code>, declared on the <code>html</code> element.
</p>
<pre><code class="language-css">html {
  --color-accent: #008ef5;
}</code></pre>
<p>
  We want that same accent color in JavaScript without repeating it. The first thing we need to do is get the computed style of the <code>html</code> element using <code>getComputedStyle</code>.
</p>
<pre><code class="language-javascript">const rootStyle = getComputedStyle(document.documentElement);</code></pre>

<p>
  And a thing about <code>documentElement</code> that I learned:
</p>

<blockquote>
  <p>
    For any non-empty HTML document, document.documentElement will always be an <code>&lt;html&gt;</code> element.
  </p>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement">
      From MDN web docs “Document.documentElement”
    </a>
  </cite>
</blockquote>

<p>
  That means that <code>:root</code> and <code>html</code> are the same for non-empty HTML pages.
</p>

<p>
  We stored the computed style of the <code>html</code> element as <code>rootStyle</code>. That’s a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration"><code>CSSStyleDeclaration</code></a>. With that, we can use <code>getPropertyValue</code> to get the value of <code>--color-accent</code>.
</p>

<pre><code class="language-javascript">const accentColor = rootStyle.getPropertyValue("--color-accent");
console.log(accentColor); // "#008ef5"</code></pre>

<p>
  This shows a single use. To get the value of a second property, we’d need to invoke <code>getPropertyValue</code> again with another property name. This works fine, but can add a lot of code if you need to access a lot of custom props. We can make it more terse by wrapping it in a function:
</p>

<pre><code class="language-javascript">const getCustomPropVal = (name, style) => style.getPropertyValue(name);
const accentColor = getCustomPropVal("--color-accent", rootStyle);</code></pre>

<p>
  We can slim it down more with a default value for <code>style</code>. This works if we have a common element–like <code>html</code> where we’ve declared custom props:
</p>

<pre><code class="language-javascript">const getCustomPropVal = (name, style = rootStyle) => style.getPropertyValue(name);
const accentColor = getCustomPropVal("--color-accent");</code></pre>

<p>
  The <code>style</code> parameter gives <code>getCustomPropVal</code> flexibility. For example, say we declared a <code>--max-width</code> property on the <code>main</code> element:
</p>

<pre><code class="language-javascript">const maxWidth = getCustomPropVal(
  "--max-width",
  getComputedStyle(document.querySelector("main"))
);</code></pre>

<p>
  Using <code>getCustomPropVal</code> we can take this further. Say we have a bunch of custom props on an element. We can put the prop names in an array and loop over it, invoking <code>getCustomPropVal</code> for each name to get the value. I won’t go into detail here because it’s a bit of a tangent, but <a href="https://mapping-css-custom-props-to-js.glitch.me/basic/">the basic demo</a> has an example.
</p>

<h3>When I Use This Approach</h3>
<p>
  I use this when I need access to only a couple custom CSS properties in JavaScript. The code is a little heavy and it starts to fall down when I need custom props from different elements. Still, it’s a fine approach that gets the job done when the job at hand is small.
</p>
<p>
  But, I wanted to go further. I want an automatic way to make all current and future custom properties available in JavaScript. This basic approach is the foundation for the following more advanced approaches.
</p>

<h2 id="the-approach-i-wanted">The Approach I Wanted (that doesn’t work)</h2>

<p>
  If you’re following along in the demo, this is the
  <a href="https://mapping-css-custom-props-to-js.glitch.me/want/">“Want”</a> example.
</p>

<p>
  For this example, we have a few custom props declared on the <code>html</code> element:
</p>

<pre><code class="language-css">html {
  --color-bg: 28, 35, 30;
  --color-txt: #f1f1f1;
  --color-accent: #ffe000;
  --font-sans: helvetica, arial, sans-serif;
}</code></pre>

<p>
  We begin this approach again with <code>getComputedStyle</code>, like the basic approach:
</p>

<pre><code class="language-javascript">const rootStyle = getComputedStyle(document.documentElement);</code></pre>

<p>
  If we log <code>rootStyle</code> we see a <code>CSSStyleDeclaration</code>. It’s an object with a whole lotta keys and values that are CSS properties and values. When I looked at it I thought; “<i>great, here's every computed style for the document, let’s just grab the custom properties and values from there.</i>” Here’s how I thought we’d go about that:
</p>

<pre><code class="language-javascript">const customProps = Object.keys(rootStyle)
  .filter(k => k.indexOf("--") === 0);</code></pre>

<p>
  This creates a new array–<code>customProps</code>–made up of keys of <code>rootStyle</code> that begin with the string <code>"--"</code>.
</p>

<blockquote>
  <p>
    Property names that are prefixed with <code>--</code>, like <code>--example-name</code>, represent custom properties…
  </p>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*">
      From MDN web docs “Custom properties (--*): CSS variables”
    </a>
  </cite>
</blockquote>

<p>
  From here we’d expect <code>customProps</code> to contain all custom property names we’d declared on the <code>html</code> element. And if we have the names, we’d be able to get the values from <code>rootStyle</code>. Let’s log <code>customProps</code> to see what we have:
</p>

<pre><code class="language-javascript">console.log(customProps); // []</code></pre>

<p>
  An empty array? What happened? Unfortunately, I don’t know. For some reason, custom properties are not available in the <code>CSSStyleDeclaration</code> produced by <code>getComputedStyle</code>. This behavior is the same across recent versions of Chrome, Firefox, and Safari at the time of this post.
</p>

<p>
  My guess is that this is documented in a spec somewhere, but I wasn’t able to track it down. If you know why, <a href="mailto:me@tylergaw.com">let me know</a>. Since that doesn’t work, let’s try another approach, but first a bit of background on what we’ll need.
</p>

<h2>document.styleSheets</h2>

<p>
  A reason I was hopeful that the previous approach would work is because I thought it would help us avoid <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/styleSheets"><code>document.styleSheets</code></a>. There’s nothing <i>wrong</i> with it. It provides exactly what’s needed. Using it just adds a lot of code.
</p>

<blockquote>
  <p>
    The styleSheets read-only property…returns a StyleSheetList of CSSStyleSheet objects, for stylesheets explicitly linked into or embedded in a document.
  </p>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/styleSheets">
      From MDN web docs “Document​OrShadow​Root​.style​Sheets”
    </a>
  </cite>
</blockquote>

<p>
  Once we access <code>document.styleSheets</code> we need to loop over them, and for each of them, we need to loop over every rule, and for each rule, loop over it’s properties. Again, this works exactly how it’s supposed to, it’s just a lot of loopin’ to do. I’ve written about using <code>document.styleSheets</code> before in <a href="https://tylergaw.com/articles/reacting-to-media-queries-in-javascript/">“Reacting to Media Queries in JavaScript”</a>.
</p>

<h3>Security Concerns</h3>

<p>
  <code>document.styleSheets</code> exposes all <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet"><code>CSSStyleSheet</code>s</a> for a document via the <code>cssRules</code> property. That includes stylesheets that are not on the current domain. This can cause errors because of security issues.
</p>

<blockquote>
  <p>
    In some browsers, if a stylesheet is loaded from a different domain, calling <code>cssRules</code> results in <code>SecurityError</code>.
  </p>
  <cite>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet#Notes">
      From MDN web docs “CSSStyle​Sheet”
    </a>
  </cite>
</blockquote>

<p>
  For our purposes this is OK. If you use example code from this post on a site that includes stylesheets across domains, you might need to wrap it in a <code>try/catch</code> block. Nothing we can’t work around, but something to keep in mind.
</p>

<p>
  We’ll be using <code>document.styleSheets</code> for the rest of the approaches. It’s how we’ll get access to every custom property for a given page.
</p>

<h2 id="the-approach-that-works-in-chrome">The Approach That Works in Chrome (and maybe more in the future)</h2>

<p>
  If you’re following along in the demo, this is the
  <a href="https://mapping-css-custom-props-to-js.glitch.me/future-maybe/">“Future Maybe”</a> example.
</p>

<p>
  Like it says in the title, at the time of this writing, this approach only works in Chrome. Firefox and Safari will catch with a warning and not display expected results. We’ll look at why later. For now let’s set a foundation for this example and the later example with widest support.
</p>

<p>
  Let’s write a function that produces an array of arrays for every custom property for a given page. Each child array will contain two members; a CSS custom prop name and value. Building on the previous examples, we have CSS that looks like this:
</p>

<pre><code class="language-css">html {
  --color-bg: 28, 35, 30;
  --color-txt: #f1f1f1;
  --color-accent: #ffe000;
  --font-sans: helvetica, arial, sans-serif;
  --gradient-one: linear-gradient(-20deg, #8900f5, var(--color-accent), #00d8f5);
}

span {
  --color-bg-hello: rgba(134, 200, 181, 0.5);
}

.demo-output {
  --color-special: #fff5f5;
}</code></pre>

<p>
  Notice we have custom props declared on multiple elements. Also that we’ve delcared one custom prop that uses another custom prop. More on that later.
</p>

<pre><code class="language-javascript">const getCSSCustomPropIndex = () => [...document.styleSheets].reduce((accum, sheet) => {
  // work will happen here
  return prev;
}, []);</code></pre>

<p>
  Nothing useful is happening yet. If we invoke <code>getCSSCustomPropIndex</code>, we’d get an empty array. What are we doing with <code>[...document.styleSheets]</code>?
</p>
<p>
  <code>document.styleSheets</code> returns a <code>StyleSheetList</code> which is an “an array-like object”. That means it doesn’t have array methods like <code>reduce</code>. With that snippet we’re using spread syntax to put each item of the <code>StyleSheetList</code> into a regular array. This isn’t a requirement, but I prefer to use normal array methods when possible.
</p>
<p>
  It’s also worth pointing out we’re providing an empty array as an initial value to <code>reduce</code>. Let’s set the stage a little more.
</p>

<pre><code class="language-javascript">const getCSSCustomPropIndex = () => [...document.styleSheets].reduce((accum, sheet) => {
  try {
    return accum.concat([/* more work will happen here */]);
  } catch (err) {
    console.warn(err);
    return accum;
  }
}, []);</code></pre>

<p>
  Earlier I mentioned the security concerns when accessing <code>CSSStyleSheet</code>. We’re about to do just that so we start out with a <code>try/catch</code>. That <code>catch</code> here doesn’t do anything useful, only keeps our script from blowing up. That could be enough for production code, because it only means you skip <code>CSSStyleSheet</code>s from domains other than the one this JavaScript is executed.
</p>

<p>
  The other new work we’re doing is <code>return accum.concat([])</code>. If we invoke <code>getCSSCustomPropIndex</code> now and the page has a single stylesheet, we’d end up with <code>[[]]</code>. Not the end result we’re after, but a step forward.
</p>

<p>
  Before, when I said working with <code>document.styleSheets</code> requires a lot of looping, we’re at that point. Our <code>reduce</code> function gets each <code>CSSStyleSheet</code>. Now we need to look at every CSS rule in every stylesheet. For that, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet#Properties"><code>cssRules</code></a> property.
</p>

<pre><code class="language-javascript">const getCSSCustomPropIndex = () => [...document.styleSheets].reduce((accum, sheet) => {
  try {
    return accum.concat(
      [...sheet.cssRules].reduce((accum, rule) => {
        /* more work will happen here */
        console.log(rule);
        return accum.concat([rule.selectorText]);
      }, [])
    );
  } catch (err) {
    console.warn(err);
    return accum;
  }
}, []);</code></pre>

<p>
  What are we doing here? We’re adding the <code>selectorText</code> for every CSS rule–the chunk of properties between selector and braces <code>{}</code>–to an array. If we invoke <code>getCSSCustomPropIndex</code> we have something like this:
</p>

<pre><code class="language-javascript">["html", "body", "div", "main", ".content", /* the rest of the selectors across all stylesheets */]</code></pre>

<p>
  The items in that array will be different depending on the page it’s run. OK, still not what we’re after, but this step introduces an interesting new type; <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSRule"><code>CSSRule</code></a>.
</p>

<h2 id="the-approach-that-works">The Approach That Works</h2>

{{> thanks-for-reading }}
