---
layout: article
title: "Building My First PWA"
date: 2017-10-29
permalink: /articles/first-pwa
meta:
  description: Notes a making my first Progressive Web Site
---

<p class="entry-intro">
  I’ve been looking for a sandbox–and time–to sit down and learn how to build offline-capable/first web sites or “Progress Web Apps” (PWA) for a while. I learn best with hands-on approach. <a href="https://colorme.io/" target="_blank" rel="noopener">ColorMe</a> is a small site I maintain and a perfect candidate for offline functionality experimentation. This post details the steps I took, the issues I ran into, and things I learned building my first PWA.
</p>

<p>
  Quick note. This isn’t a general “How to make a PWA” post. It may not even be a good intro. There are plenty of articles and tutorials to get the basics. This post is specific to the work involved in making ColorMe a PWA.
</p>

<p>
  In a lot of posts I’ve read about building PWAs, there were common steps for building them. A simple-on-the-surface looking process. Here’s one list from Jeremy in <a href="https://adactio.com/journal/12461">“Progressing the Web.”</a>
</p>

<blockquote>
  <ol>
    <li>switch over to HTTPS,</li>
    <li>add a JSON manifest file with your metacrap, and</li>
    <li>add a service worker.</li>
  </ol>
  <cite>
    <a href="https://adactio.com/journal/12461">Jeremy Keith, “Progressing the Web.”</a>
  </cite>
</blockquote>

<p>
  OK, that seems easy enough. But that last step, that seems like it could be a lot to unpack and Jeremy does offer a disclaimer:
</p>

<blockquote>
  <p>
    That last step can be tricky if you’re new to service workers, but it’s not unsurmountable.
  </p>
  <cite>
    <a href="https://adactio.com/journal/12461">Jeremy Keith, “Progressing the Web.”</a>
  </cite>
</blockquote>
<p>
  I’ll ignore the service worker portion of the process for now and focus on the first two items.
</p>
<h2>Using HTTPS</h2>
<p>
  ColorMe already has HTTPS in place. The site is hosted on S3 and served by CloudFront so I used <a href="https://aws.amazon.com/certificate-manager/">Amazon’s Certificate Manager</a> to obtain an SSL certificate. The most difficult part of that process for me was setting up a temporary email address to confirm domain ownership. But it’s in place and has been since launch.
</p>

<h2>Adding a Manifest</h2>
<p>
  This is where things get more interesting. Including the <code>manifest.json</code> was easy. ColorMe is built using <a href="https://github.com/facebookincubator/create-react-app">Create React App</a> so I created the file in the public directory. <code>/public/manifest.json</code> The same directory as the favicon and <code>index.html</code>.
</p>
<p>
  I knew there was “stuff” that went in the manifest, but I had questions about specifics. What keys can I use? What are example values for each key? And what key-values am I supposed to have? The best resource I found for questions number one and two is the MDN <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web App Manifest documentation</a>. It lists available keys and example values.
</p>

<ul>
  <li>
    Add <code>short_name</code> and <code>name</code></li>
  <li>
    Referenced manifest in index.html <code>link rel="manifest" href="/manifest.json"</code></li>
  <li>
    Created and added three launch icon sizes. At least one (192x192) is required.</li>
  <li>
    Add colors: background_color and theme_color</li>
  <li>
    Add display: standalone</li>
  <li>
    Added <code>noscript</code> content. Would be better to have some type of useful experience without JS, but will try that another time. It's interesting to think how to make a site like this provide something of value without JS.</li>
  <li>
    Noticed I was still failing the Splash Screen audit so added more icon sizes; 256x256, 384x384, and 512x512. I'm not sure what each of those are for, but they were recomended.</li>
</ul>

Oh:
> If you want to manually verify that your web app manifest is set up correctly, use the Manifest tab on the Application panel of Chrome DevTools.

<p>
  I didn't realize that was a thing. Kept re-running the PWA Audit. It's great and has an "Add to homescreen" button to test the mechanism which is much appreciated since I don't have access to an Android device.
</p>

<p>
  At this point I still don’t have an PWA that can be added to any homescreen. The audit turns up one failure still:
</p>

<blockquote>
  <p>
    Failures: Site does not register a Service Worker, Manifest start_url is not cached by a Service Worker.
  </p>
</blockquote>

<h2>The Service Worker</h2>

<p>
  This was the biggest mystery for me. I understood the concept of service workers. I didn't understand what the goals of a service worker for a PWA were. Sure, it's JS, it runs in the background, but what’s the JS supposed to do?
</p>

<h3>Steps</h3>
- Following the tutorial, register the most simple service worker possible. Does nothing.
- Got hung up when listing assets to cache because my JS/CSS files are fingerprinted. This is default in create-react-app. I don't want to eject to change things. Researching what to do...
- Piggy backed on CRA build process. Once it completes building, my custom script replaces special strings in the service worker with the fingerprinted names of the CSS and JS files and an image.
- Not supposed to scale. Quick and dirty on purpose.

<p>
  This left me with a few options for caching fingerprinted files:
</p>

<ol>
  <li>Eject and modify the webpack build process</li>
  <li>Update to latest CRA and use their built-in PWA</li>
  <li>Walk away from computer, sleep on it, think about a better solution the next morning while walking my <a href="http://leela.dog">dog</a></li>
</ol>

<hr />

<h3>Piggybacking on the build script</h3>

<p>
  The default CRA build script builds the project according to the baked in webpack config. I can’t change the config–without ejecting–but I can change the build script in <code>package.json</code>. I’d already modified the script to include <code>NODE_PATH=src</code>. That makes it easier to import modules without referencing the full path. The starting build script looked like:
</p>

<pre><code class="language-javascript">NODE_PATH=src react-scripts build</code></pre>

<p>
  I knew a couple things. I knew the build process creates a file named <code>asset-manifest.json</code>. The contents of that file include the full fingerprinted names of all static assets used in the site. The contents of the manifest file:
</p>

<pre><code class="language-javascript">{
  "main.css": "static/css/main.2ebebc14.css",
  "main.css.map": "static/css/main.2ebebc14.css.map",
  "main.js": "static/js/main.7e7a1a8f.js",
  "main.js.map": "static/js/main.7e7a1a8f.js.map",
  "static/media/bgTransparent.svg": "static/media/bgTransparent.e6317315.svg"
}</code></pre>

<p>
  Those are the full filenames I need to cache with my service worker. Now I need to get those filenames into the service worker file.
</p>
<p>
  The first thing I did was add to the build script. Back in <code>package.json</code> I updated the script to look like:
</p>

<pre><code class="language-javascript">NODE_PATH=src react-scripts build && npm run generate-sw</code></pre>

<p>
  This says; “run the normal build process, then when you’re done with that run this other npm script”. That script looks like:
</p>

<pre><code class="language-javascript">"generate-sw": "node scripts/generate-sw.js"</code></pre>

<p>
  To make sure that worked, I created <code>/scripts/generate-sw.js</code> and added a single line; <code>console.log('hello')</code>. Then I ran the build script <code>npm run build</code> to make sure the project built and I saw “hello” in my terminal output. So far so good.
</p>

<h4>The generate script</h4>

<p>
  I need to get the filenames out of <code>asset-manifest.json</code> and into the array of filenames to cache in <code>service-worker.js</code>. My plan was to not get fancy with this. I only need to grab strings from one file and write them into another file. The fact that the target file is JavaScript is immaterial to this process.
</p>

<p>
  The full file is available <a href="https://github.com/tylergaw/colorme/blob/03946e9540a031075f3f691356d7aa3f4e457a2d/scripts/generate-sw.js">on GitHub</a> and I’ll go through the code in detail here.
</p>

<pre><code class="language-javascript">const manifest = require("../build/asset-manifest.json");
const fs = require("fs");
const swPath = "build/service-worker.js";</code></pre>

<p>
  First is setup. <code>asset-manifest.json</code> is JSON so we <code>require</code> it here for use as an object. We’ll use the <code>fs</code> package for reading and writing files. We store the path of the service worker for later convenience.
</p>

<pre><code class="code-muted">const manifest = require("../build/asset-manifest.json");
const fs = require("fs");
const swPath = "build/service-worker.js";</code>
<code class="language-javascript">const urlsCSV = Object.keys(manifest)
  .filter(k => !k.includes(".map"))
  .map(k => manifest[k]);</code></pre>

<p>
  Getting more interesting, but still not fancy. The goal of this chunk of code is to build an array of filenames. First, use <code>Object.keys</code> to get the keys from the manifest JSON so we can loop over an array.
</p>
<p>
  Next, we use <code>filter</code> to remove keys that include the string “.map.” If you look at <code>asset-manifest.json</code> you’ll see source maps. We don’t want to cache those. I’m not sure if there’s a best practice for or against that, but I decided it didn’t seem right for this project.
</p>
<p>
  Now that we only have keys for the files we want to cache we use <code>map</code> to create the array of filenames, <code>urlsCSV</code>;
</p>

<pre><code class="language-javascript">[
  "static/css/main.2ebebc14.css",
  "static/js/main.7e7a1a8f.js",
  "static/media/bgTransparent.e6317315.svg"
]</code></pre>

<p>
  <strong>A short tangent.</strong> Given the code above, you might be asking; <em>“why didn’t you just use <code>Object.values</code> instead of <code>Object.keys</code> plus <code>map</code>?”</em> That’s a great question with a quick answer. I’m running Node.js version 6.9.1. <code>Object.values</code> is not supported without the <code>--harmony</code> flag until version <code>7.0.0</code>. I didn’t want to upgrade Node.js for this. That’s all.
</p>

<p>
  We need to get that array of filenames into the service worker file. Again, this isn’t meant to be fancy or scalable. It’s meant to get the job done.
</p>

<pre><code class="code-muted">const manifest = require('../build/asset-manifest.json');
const fs = require('fs');
const swPath = 'build/service-worker.js';
const urlsCSV = Object.keys(manifest)
  .filter(k => !k.includes('.map'))
  .map(k => manifest[k]);</code>

<code class="language-javascript">fs.readFile(swPath, "utf8", (err, data) => {
  if (err) { return console.log("Error trying to read SW file", err); }

  const result = data.replace("%MANIFESTURLS%", JSON.stringify(urlsCSV));

  fs.writeFile(swPath, result, "utf8", err => {
    if (err) { return console.log("Error trying to write SW file", err); }
  });
});</code></pre>

<p>
  Let’s break this down. First we open the service worker file (<code>swPath</code>) for reading. The error condition isn’t important. I included it to be nice to myself in case something odd happens during a build.
</p>

<p>
  The next line is the point of this script. It searches the contents of service worker file (<code>results</code>) for the unique string <code>“%MANIFESTURLS%”</code>. When found it’s replaced with a JSON stringified version of our filenames array, <code>urlsCSV</code>.
</p>

<hr />

<h3>Thoughts/Notes:</h3>
<ul>
  <li>I didn't know Service Workers usurped AppCache, which was an awful thing</li>
  <li>This feels a bit like reading about Responsive Design for the first time</li>
  <li><code>caches</code> is a global variable. On <code>window</code> scope.</li>
  <li>Usually, when I thought my service working wasn't updating correctly, it wasn't that, it was cache at Cloudfront.</li>
  <li>Every change you make; html, css, js, images, etc. you have to change the cache version to make sure the old sw is deleted and new one takes over. (this might be true)</li>
</ul>

<h3>Reference</h3>
<ul>
  <li>https://developers.google.com/web/fundamentals/web-app-manifest/</li>
  <li>https://developer.mozilla.org/en-US/docs/Web/Manifest</li>
  <li>https://developers.google.com/web/tools/lighthouse/audits/registered-service-worker</li>
  <li>(most helpful, but dated) https://codelabs.developers.google.com/codelabs/offline</li>
  <li>(most helpful for driving home concepts and uses) https://jakearchibald.com/2014/offline-cookbook/</li>
</ul>
