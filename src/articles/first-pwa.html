---
layout: article
title: "Building My First PWA"
date: 2017-10-30
permalink: /articles/first-pwa
meta:
  description: Notes a making my first Progressive Web Site
---

<p class="entry-intro">
  I’ve been looking for a sandbox–and time–to sit down and learn how to build offline-capable/first web sites or “Progressive Web Apps” (PWA) for a while. I learn best with hands-on approach. <a href="https://colorme.io/" target="_blank" rel="noopener">ColorMe</a> is a site I maintain and a perfect candidate for offline experimentation. This post details the steps I took, the issues I ran into, and things I learned building my first PWA.
</p>

<p>
  Quick note. This isn’t a general “How to make a PWA” post. It may not even be a good intro. There are plenty of articles and tutorials to get the basics. This post is specific to the work involved in making ColorMe a PWA.
</p>

<p>
  In a lot of what I’ve read about PWAs, there’s been common steps for building them. A simple-on-the-surface looking process. Here’s one list from Jeremy in <a href="https://adactio.com/journal/12461">“Progressing the Web.”</a>
</p>

<blockquote>
  <ol>
    <li>switch over to HTTPS,</li>
    <li>add a JSON manifest file with your metacrap, and</li>
    <li>add a service worker.</li>
  </ol>
  <cite>
    <a href="https://adactio.com/journal/12461">Jeremy Keith, “Progressing the Web.”</a>
  </cite>
</blockquote>

<p>
  OK, that seems easy enough. Except that last step. That seems like it could be a lot to unpack. Jeremy does offer a disclaimer:
</p>

<blockquote>
  <p>
    That last step can be tricky if you’re new to service workers, but it’s not unsurmountable.
  </p>
  <cite>
    <a href="https://adactio.com/journal/12461">Jeremy Keith, “Progressing the Web.”</a>
  </cite>
</blockquote>
<p>
  I’ll ignore the service worker part of the process for now and focus on the first two items.
</p>
<h2>Using HTTPS</h2>
<p>
  ColorMe already has HTTPS in place. I host it on S3 and serve it through CloudFront. I use <a href="https://aws.amazon.com/certificate-manager/">Amazon’s Certificate Manager</a> to add an SSL certificate. HTTPS is in place and has been since launch.
</p>

<h2>Adding a Manifest</h2>
<p>
  This is where things got more interesting. ColorMe is built with <a href="https://github.com/facebookincubator/create-react-app">Create React App</a> (CRA) so I created the <code>manifest.json</code> file in the <code>public</code> directory. The same directory as the favicon and <code>index.html</code>. Anything in the <code>public</code> directory gets copied to the <code>build</code> directory as is. That’s what we need for <code>manifest.json</code>.
</p>

<h3>Doesn’t CRA do PWA stuff out of the box?</h3>
<p>
  Yes. CRA added built-in support for PWAs in version <code>1.0.0</code>. ColorMe is still on version <code>0.8.4</code>. That was the latest version when I created the project and haven’t had a reason to update.
</p>
<p>
  I could have updated CRA to use the built-in PWA, but I didn’t want to miss the opportunity to learn step-by-step. Doing this myself, taking the long, “dumb” way, helped internalize the why and the how of each step. On future CRA-built projects, I’ll use the latest version with built-in PWA support. With that out of the way, I’ll detail the steps for all this “metacrap.”
</p>

<p>
  I knew there was “stuff” that went in the manifest, but I wasn’t sure about specifics. What keys can I use? What are example values for each key? And what key-values am I supposed to have? The best resource I found for questions number one and two is the MDN <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web App Manifest documentation</a>. It lists available keys and example values.
</p>

<h3>Lighthouse</h3>
<p>
  For the third question, I turned to <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse audits</a> in Chrome dev tools. Before adding anything to the manifest, I ran a PWA audit. It reported items needed to meet the minimum requirements for a PWA (according to the audit).
</p>

<figure>
  <img src="/articles/assets/post-image-pwa-audit-before.png" alt="">
  <figcaption>
    A pre-pwa audit of colorme.io
  </figcation>
</figure>

<p>
  With the audit report as a starting point, I hit each item on the list. Most important, I referenced the manifest in the <code>head</code> of <code>index.html</code>. This uses the CRA-specific <code>%PUBLIC_URL%</code>.
</p>

<pre><code class="language-javascript">&lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt;</code></pre>

<p>
  Most items in the manifest are straightforward enough so I won’t go line-by-line. But I will call out a couple items that took a bit more work. You can see the complete file <a href="https://github.com/tylergaw/colorme/blob/develop/public/manifest.json">on GitHub</a> and below:
</p>

<pre><code class="language-javascript">{
  "background_color": "#ffffff",
  "theme_color": "#B50003",
  "display": "standalone",
  "short_name": "ColorMe",
  "name": "ColorMe",
  "start_url": "/",
  "icons": [
    {
      "src": "launcher-icon-48x48.png",
      "type": "image/png",
      "sizes": "48x48"
    },
    {
      "src": "launcher-icon-96x96.png",
      "type": "image/png",
      "sizes": "96x96"
    },
    {
      "src": "launcher-icon-192x192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "launcher-icon-256x256.png",
      "type": "image/png",
      "sizes": "256x256"
    },
    {
      "src": "launcher-icon-384x384.png",
      "type": "image/png",
      "sizes": "384x384"
    },
    {
      "src": "launcher-icon-512x512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ]
}</code></pre>

<h3>Icon sizes</h3>
<p>
  As you can see in the manifiest, I included six different icon sizes. The audit requires two sizes; 192x192 and 512x512. The former for the homescreen icon on Android, the latter as an icon for a splash screen on Android.
</p>
<p>
  I’m not sure if the other four sizes are necessary, but I saw those sizes in tutorials and examples so I figured it wouldn’t hurt to include them.
</p>

<h3>Theme color</h3>
<p>
  Another requirement–per the audit–was to add a <code>theme-color</code> meta tag to <code>index.html</code>:
</p>

<pre><code class="language-javascript">&lt;meta name="theme-color" content="#B50003"&gt;</code></pre>

<blockquote>
  <p>
    The theme-color meta tag ensures that the address bar is branded when a user visits your site as a normal webpage.
  </p>
</blockquote>

<h3>noscript</h3>
<p>
  Another failing audit was “Contains Some Content When JavaScript Is Not Available.” For that, I added <code>noscript</code> content. It doesn’t do anything except apologize for not working without JavaScript. It would be better to have some type of useful experience without JS, but I’ll save that for another time. It’s interesting to think how to make a 100% static site like this provide value without JavaScript.
</p>

<h3>“According to the audit”</h3>
<p>
  I used specific language like; “per the audit” and “according to the audit” on purpose here. Some of these aren’t universal. For example, the <code>theme_color</code> property and the <code>theme-color</code> meta tag have no effect on Mobile Safari or Mobile Chrome on iOS as far as I can tell. For the purposes of this exercise, I’m working towards a 100% on the audit. I’m not sure every item is needed for every project. As usual, it depends.
</p>

<h3>The Manifest tab</h3>
<p>
  Every time I’d make a change to the manifest I’d re-run the PWA audit to check the results. This was slow. I didn’t realize there was a tab in Chrome dev tools for inspecting the <code>manifest.json</code> results. I found it early enough in the process that it helped speed things along. It also has an “Add to homescreen” button to test that mechanism. That’s much appreciated because I don’t have access to an Android device for proper testing.
</p>

<p>
  At this point I still don’t have a valid PWA that can be added to any homescreen. The audit turns up one last failure:
</p>

<blockquote>
  <p>
    Failures: Site does not register a Service Worker, Manifest start_url is not cached by a Service Worker.
  </p>
</blockquote>

<p>
  With the rest of the manifest in place, I turned my attention to the meat of the project.
</p>

<h2>The Service Worker</h2>

<hr />
<p>
  This was the biggest mystery for me. I understood the concept of service workers. I didn't understand what the goals of a service worker for a PWA were. Sure, it's JS, it runs in the background, but what’s the JS supposed to do?
</p>

<h3>Steps</h3>
- Following the tutorial, register the most simple service worker possible. Does nothing.
- Got hung up when listing assets to cache because my JS/CSS files are fingerprinted. This is default in create-react-app. I don't want to eject to change things. Researching what to do...
- Piggy backed on CRA build process. Once it completes building, my custom script replaces special strings in the service worker with the fingerprinted names of the CSS and JS files and an image.
- Not supposed to scale. Quick and dirty on purpose.

<p>
  This left me with a few options for caching fingerprinted files:
</p>

<ol>
  <li>Eject and modify the webpack build process</li>
  <li>Update to latest CRA and use their built-in PWA</li>
  <li>Walk away from computer, sleep on it, think about a better solution the next morning while walking my <a href="http://leela.dog">dog</a></li>
</ol>

<hr />

<h3>Piggybacking on the build script</h3>

<p>
  The default CRA build script builds the project according to the baked in webpack config. I can’t change the config–without ejecting–but I can change the build script in <code>package.json</code>. I’d already modified the script to include <code>NODE_PATH=src</code>. That makes it easier to import modules without referencing the full path. The starting build script looked like:
</p>

<pre><code class="language-javascript">NODE_PATH=src react-scripts build</code></pre>

<p>
  I knew a couple things. I knew the build process creates a file named <code>asset-manifest.json</code>. The contents of that file include the full fingerprinted names of all static assets used in the site. The contents of the manifest file:
</p>

<pre><code class="language-javascript">{
  "main.css": "static/css/main.2ebebc14.css",
  "main.css.map": "static/css/main.2ebebc14.css.map",
  "main.js": "static/js/main.7e7a1a8f.js",
  "main.js.map": "static/js/main.7e7a1a8f.js.map",
  "static/media/bgTransparent.svg": "static/media/bgTransparent.e6317315.svg"
}</code></pre>

<p>
  Those are the full filenames I need to cache with my service worker. Now I need to get those filenames into the service worker file.
</p>
<p>
  The first thing I did was add to the build script. Back in <code>package.json</code> I updated the script to look like:
</p>

<pre><code class="language-javascript">NODE_PATH=src react-scripts build && npm run generate-sw</code></pre>

<p>
  This says; “run the normal build process, then when you’re done with that run this other npm script”. That script looks like:
</p>

<pre><code class="language-javascript">"generate-sw": "node scripts/generate-sw.js"</code></pre>

<p>
  To make sure that worked, I created <code>/scripts/generate-sw.js</code> and added a single line; <code>console.log('hello')</code>. Then I ran the build script <code>npm run build</code> to make sure the project built and I saw “hello” in my terminal output. So far so good.
</p>

<h4>The generate script</h4>

<p>
  I need to get the filenames out of <code>asset-manifest.json</code> and into the array of filenames to cache in <code>service-worker.js</code>. My plan was to not get fancy with this. I only need to grab strings from one file and write them into another file. The fact that the target file is JavaScript is immaterial to this process.
</p>

<p>
  The full file is available <a href="https://github.com/tylergaw/colorme/blob/03946e9540a031075f3f691356d7aa3f4e457a2d/scripts/generate-sw.js">on GitHub</a> and I’ll go through the code in detail here.
</p>

<pre><code class="language-javascript">const manifest = require("../build/asset-manifest.json");
const fs = require("fs");
const swPath = "build/service-worker.js";</code></pre>

<p>
  First is setup. <code>asset-manifest.json</code> is JSON so we <code>require</code> it here for use as an object. We’ll use the <code>fs</code> package for reading and writing files. We store the path of the service worker for later convenience.
</p>

<pre><code class="code-muted">const manifest = require("../build/asset-manifest.json");
const fs = require("fs");
const swPath = "build/service-worker.js";</code>
<code class="language-javascript">const urlsCSV = Object.keys(manifest)
  .filter(k => !k.includes(".map"))
  .map(k => manifest[k]);</code></pre>

<p>
  Getting more interesting, but still not fancy. The goal of this chunk of code is to build an array of filenames. First, use <code>Object.keys</code> to get the keys from the manifest JSON so we can loop over an array.
</p>
<p>
  Next, we use <code>filter</code> to remove keys that include the string “.map.” If you look at <code>asset-manifest.json</code> you’ll see source maps. We don’t want to cache those. I’m not sure if there’s a best practice for or against that, but I decided it didn’t seem right for this project.
</p>
<p>
  Now that we only have keys for the files we want to cache we use <code>map</code> to create the array of filenames, <code>urlsCSV</code>;
</p>

<pre><code class="language-javascript">[
  "static/css/main.2ebebc14.css",
  "static/js/main.7e7a1a8f.js",
  "static/media/bgTransparent.e6317315.svg"
]</code></pre>

<p>
  <strong>A short tangent.</strong> Given the code above, you might be asking; <em>“why didn’t you just use <code>Object.values</code> instead of <code>Object.keys</code> plus <code>map</code>?”</em> That’s a great question with a quick answer. I’m running Node.js version 6.9.1. <code>Object.values</code> is not supported without the <code>--harmony</code> flag until version <code>7.0.0</code>. I didn’t want to upgrade Node.js for this. That’s all.
</p>

<p>
  We need to get that array of filenames into the service worker file. Again, this isn’t meant to be fancy or scalable. It’s meant to get the job done.
</p>

<pre><code class="code-muted">const manifest = require('../build/asset-manifest.json');
const fs = require('fs');
const swPath = 'build/service-worker.js';
const urlsCSV = Object.keys(manifest)
  .filter(k => !k.includes('.map'))
  .map(k => manifest[k]);</code>

<code class="language-javascript">fs.readFile(swPath, "utf8", (err, data) => {
  if (err) { return console.log("Error trying to read SW file", err); }

  const result = data.replace("%MANIFESTURLS%", JSON.stringify(urlsCSV));

  fs.writeFile(swPath, result, "utf8", err => {
    if (err) { return console.log("Error trying to write SW file", err); }
  });
});</code></pre>

<p>
  Let’s break this down. First we open the service worker file (<code>swPath</code>) for reading. The error condition isn’t important. I included it to be nice to myself in case something odd happens during a build.
</p>

<p>
  The next line is the point of this script. It searches the contents of service worker file (<code>results</code>) for the unique string <code>“%MANIFESTURLS%”</code>. When found it’s replaced with a JSON stringified version of our filenames array, <code>urlsCSV</code>.
</p>

<hr />

<h3>Thoughts/Notes:</h3>
<ul>
  <li>I didn't know Service Workers usurped AppCache, which was an awful thing</li>
  <li>This feels a bit like reading about Responsive Design for the first time</li>
  <li><code>caches</code> is a global variable. On <code>window</code> scope.</li>
  <li>Usually, when I thought my service working wasn't updating correctly, it wasn't that, it was cache at Cloudfront.</li>
  <li>Every change you make; html, css, js, images, etc. you have to change the cache version to make sure the old sw is deleted and new one takes over. (this might be true)</li>
</ul>

<h3>Reference</h3>
<ul>
  <li>https://developers.google.com/web/fundamentals/web-app-manifest/</li>
  <li>https://developer.mozilla.org/en-US/docs/Web/Manifest</li>
  <li>https://developers.google.com/web/tools/lighthouse/audits/registered-service-worker</li>
  <li>(most helpful, but dated) https://codelabs.developers.google.com/codelabs/offline</li>
  <li>(most helpful for driving home concepts and uses) https://jakearchibald.com/2014/offline-cookbook/</li>
</ul>
