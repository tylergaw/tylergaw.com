---
layout: article.html
title: "Dynamic Redux Reducers"
date: "2018-01-07"
permalink: /articles/dynamic-redux-reducers
meta:
  description: Details of an approach to adding Redux Reducers after initial store creation.
  image: /articles/assets/post-image-first-pwa-social.png
---

<p>
  This post is specific to a need I had on recent React / Redux project. It’s a
  common need and one I’d run into before, but this was the first time I needed to
  come up with a solution for it. This was difficult for me. I had to slow down
  and take time to internalize what I was trying to do and all the pieces involved.
  My hope is that this post will help someone else also working to figure
  this out.
</p>
<p>
  I’ll detail my process in this post. Here’s a
  <a href="https://qk3n9xmm3w.codesandbox.io">live demo</a> and an
  <a href="https://codesandbox.io/s/qk3n9xmm3w">editable sandbox</a>.
  The best way to see the effects is do open the Redux dev tools.
</p>

<p>
  If you’re reading this I’m going to assume you have knowledge of Redux and
  are using it with React by way of <code>react-redux</code>.
</p>

<h2>What am I trying to do and why?</h2>
<p>
  In standard usage of Redux, you provide your reducer functions at the time you
  initialize the store with <code>createStore</code>. I wanted to add reducer
  functions later, on demand.
</p>
<p>
  A lot of folks need to do this because they’re code-splitting so their reducers
  are not available at <code>createStore</code> time. That’s a perfect use for dynamic
  reducers.
</p>
<p>
  My project isn’t using code-splitting. For me, this was just a preference. I
  didn't want to have to spread info about my modules throughout my project structure.
  I want each feature to live in a directory, isolated as much as possible.
  That means placing each feature’s reducers alongside it's components, selectors,
  tests, etc. I could have done that and still imported the reducers in the
  main reducer creation, but then I’d have to couple the feature to the main
  reducer creation. I didn't want to reference files all over the place.
</p>

<h2>Existing solutions</h2>
<p>
  In my Googling for an existing solution I landing on
  <a href="https://stackoverflow.com/a/33044701">this Stack Overflow question and answer</a>.
  The answer is from Dan Abramov so I knew it was the way to go. My solution uses
  90% of that answer.
</p>
<p>
  In Dan’s answer, it all made sense to me until his example of how to inject
  the reducers. I’m using React Router, but I define my routes that way. I didn’t
  want to have to change how I defined my routes for this. I also couldn’t find
  official documentation for things he used in his example so I wanted to avoid
  copy / paste. I wanted to fully understand the code I was adding to my project.
</p>
<p>
  It’s also worth mentioning two projects I came across in my search.
  <a href="https://github.com/ioof-holdings/redux-dynamic-reducer">redux-dynamic-reducer</a>
  and <a href="https://github.com/asteridux/paradux">paradux</a>. I didn’t try
  either of them because I didn’t see the need in adding another dependency, but
  maybe they’ll work for you.
</p>

<h2>Code</h2>
<p>
  You can follow along in the <a href="https://codesandbox.io/s/github/tylergaw/redux-dynamic-reducers/tree/master/">CodeSandbox</a>.
  I’ll start with creating the root reducer in <code>/rootReducer.js</code>
</p>

<pre><code class="language-javascript">import { combineReducers } from "redux";
import layout from "./reducers/layout";
import home from "./reducers/home";

/**
 * @param {Object} - key/value of reducer functions
 */
const createReducer = asyncReducers =>
  combineReducers({
    home,
    layout,
    ...asyncReducers
  });

export default createReducer;</code></pre>

<p>
  I pulled this code from Dan’s <abbr title="Stack Overflow">SO</abbr> answer.
  In it we have two reducer functions; <code>layout<code> and <code>home</code>.
  Those are reducers we know about at this time so we’re comfortable including them
  here.
</p>
<p>
  The key detail here is the <code>asyncReducers</code> parameter. Adding the
  contents of that object to the object given to <code>combineReducers</code> is
  how we sneak in dynamic reducers later.
</p>
<p>
  Next up is store creation in <code>/initializeStore.js</code>. Again, most
  of this code is from Dan’s example.
</p>

<pre><code class="language-javascript">import { createStore } from "redux";
import createReducer from "./rootReducer";

const initializeStore = () => {
  const store = createStore(createReducer());

  store.asyncReducers = {};
  store.injectReducer = (key, reducer) => {
    store.asyncReducers[key] = reducer;
    store.replaceReducer(createReducer(store.asyncReducers));
    return store;
  };

  return store;
};

export default initializeStore;</code></pre>

<p>
  The first line of <code>initializeStore</code> is where we create the Redux
  store will the initial reducers from <code>createReducer</code>. In standard
  Redux usage, this is all you’d need. The store is set up and ready with the
  <code>home</code> and <code>layout</code> reducers.
</p>
<p>
  <code>createStore</code> returns a plain object so we’ll take advantage of that
  by tacking helpful items onto it. We’ll use <code>store.asyncReducers</code> to house
  our dynamic reducers. With <code>store.injectReducer</code> I deviate from
  Dan’s example. The function does the same thing as his <code>injectAsyncReducer</code>,
  but I attach it to the <code>store</code> object for convenience that I’ll
  later.
</p>
<p>
  <code>injectReducer</code> has two responsibilities. First, store all dynamic
  reducers in <code>asyncReducers</code>. This ensures that each time we call
  <code>injectReducer</code> we don’t lose previously added reducers. Next up
  is the main work. <a href="https://redux.js.org/docs/api/Store.html#replaceReducer"><code>replaceReducer</code></a>
  isn’t custom, it’s part of Redux. It does does what it says on the tin.
  Calling tt replaces the reducer function with one you give it.
</p>

<h3>Where things got tricky for me</h3>
<p>
  At this point everything seemed straightforward to me, but I got lost fast. We
  have a store, we have a function to add new reducers. How and where to we
  call that function though? In all my frantic Googling, I couldn’t find an
  example that worked for my setup.
</p>
<p>
  It took me a while to figure out where I could access that <code>store</code>
  object. I had clues though. In my entry point file <code>/index.js</code> I
  was using the standard <code>Provider</code> component.
</p>
<pre><code class="language-javascript">import React from "react";
import { render } from "react-dom";
import { Provider } from "react-redux";
import initializeStore from "./initializeStore";
import App from "./App";

const store = initializeStore();
render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById("root")
);</code></pre>

<p>
  Giving the <code>store</code> to <code>Provider</code> makes it available to
  all child components by way of the <code>connect</code> function. I read more
  about how that works and found out that <code>store</code> is also available
  in the <code>context</code> of each component. If you’ve read anything about
  React <code>context</code>, you've probably read that you shouldn't use it.
  For these purposes it seemed OK. Time will tell if that’s correct or not.
  More details on <code>context</code> usage to follow.
</p>

<h2>Putting the pieces together</h2>

<p>
  Each time I add a new reducer, I want to use as little code as possible. To
  accomplish this, I use a higher order component in <code>/withReducer.js</code> to
  handle the work of injecting reducers.
</p>

<pre><code class="language-javascript">import React from "react";
import { object } from "prop-types";

const withReducer = (key, reducer) => WrappedComponent => {
  const Extended = (props, context) => {
    context.store.injectReducer(key, reducer);
    return &lt;WrappedComponent {...props} /&gt;
  };

  Extended.contextTypes = {
    store: object
  };

  return Extended;
};

export { withReducer };</pre></code>

<p>
  Here’s example usage in <code>routes/Records/Records.js</code>:
</p>

<pre><code class="language-javascript">import { withReducer } from "../../withReducer";
import reducer from "./ducks";

const Records = () => (...);
export default withReducer("records", reducer)(Records);</code></pre>

<p>
  Let’s start with usage in <code>Records.js</code>. We import the records
  reducer from <code>ducks</code>. The reducer doesn’t do much. It sets hard-coded
  initial state, then returns it as-is. The component acts like a container
  component. It could be <code>connect</code>ed but for the purposes of this
  demo, I left it out.
</p>
<p>
  The pertinent bit is the last line. There we call <code>withReducer</code> and
  provide it a key of “records” and the record reducer. Then we invoke the
  returned function–more on that next–providing the <code>Records</code> component.
</p>
<p>
  <code>Records</code> is a normal component that we import and use as
  <code>&lt;Records /&gt;</code>.
</p>

<h3>The withReducer component</h3>
<p>
  <code>withReducer</code> is a <a href="https://reactjs.org/docs/higher-order-components.html">Higher-Order Component</a>.
  The <code>key</code> parameter will be used as the key in the Redux state tree.
  The <code>reducer</code> paramter is the reducer to add. It returns a function
  that accepts a single parameter, <code>WrappedComponent</code>. That’s expected
  to be a valid React component. In the usage example above, that’s the
  <code>Records</code> component.
</p>
<p>
  Let’s jump ahead to an important part of <code>withReducer</code> that was
  new to me and maybe a bit confusing.
</p>
<pre><code class="language-javascript">...
Extended.contextTypes = {
  store: object
};
...</code></pre>
<p>
  Because I used a stateless component–<code>Extended</code>–I must define
  a <code>contextTypes</code> property to be able to access <code>context</code>
  within the component. This is documented in the official React docs:
</p>
<blockquote>
  <p>
    Stateless functional components are also able to reference context if contextTypes is defined as a property of the function.
  </p>
  <cite>
    <a href="https://reactjs.org/docs/context.html#referencing-context-in-stateless-functional-components">reactjs.org/docs/context.html#referencing-context-in-stateless-functional-components</a>
  </cite>
</blockquote>

<p>
  In <code>contextTypes</code> I defined the property I want to access in the
  component, <code>store</code>. That uses the
  <code>object</code> type from the <code>prop-types</code> library.
</p>

<p>
  When you define <code>contextTypes</code> for a component, <code>context</code>
  is then provided to your component as a second parameter. That’s visible in
  the <code>Extended</code> signature:
</p>
<pre><code class="language-javascript">...
const Extended = (props, context) => {...}
...</code></pre>

<p>
  <code>Extended</code> now has access to the <code>store</code> object. That’s
  because <code>&lt;Provider store={store}&gt;</code> in <code>/index.js</code>
  makes it available to all child components via <code>context</code>.
</p>

<p>
  If you’re interested, you can see where this happens in the <code>Provider.js</code>
  source with
  <a href="https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L26"><code>getChildContext</code></a>
  and <a href="https://github.com/reactjs/react-redux/blob/master/src/components/Provider.js#L52"><code>childContextTypes</code></a>.
</p>

<p>
  Back in <code>initializeStore.js</code> I created a function on the store object,
  <code>store.injectReducer</code>. Now, I use that to add the new reducer:
</p>

<pre><code class="language-javascript">...
context.store.injectReducer(key, reducer);
...</code></pre>

<p>
  No changes happen to the original component, <code>Extended</code> just returns
  it with any original properties: <code>return &lt;WrappedComponent {...props} /&gt;;</code>
</p>

<h2>How to see it working</h2>
<p>
  At this point, the code works. But, this type of change can be difficult to
  visualize. The way that works best for me is the <a href="https://github.com/zalmoxisus/redux-devtools-extension">Redux DevTools Chrome extension</a>.
  In the <a href="https://qk3n9xmm3w.codesandbox.io">demo</a> I included the
  devtools snippet when creating the store. If you install the extension and
  view the Redux panel you can see when reducers are added.
</p>
<figure>
  <img src="https://d3vv6lp55qjaqc.cloudfront.net/items/1n0J3V3G0j1X2a1M1C00/Screen%20Recording%202018-01-07%20at%2009.52%20PM.gif" alt="Animated gif showing a new reducer added in Redux devtools Chrome extension.">
  <figcaption>
    Demo of the records reducer being added when navigating to the /records route.
  </figcation>
</figure>

<p>
  To further show the results in the demo, the record route is <code>connect</code>ed
  and displays record data from the store.
</p>
<pre><code class="language-javascript">...
const mapStateToProps = (state, props) => {
  const { match: { params: { id } } } = props;

  return {
    recordId: id,
    record: state.records[id] || {}
  };
};

export default connect(mapStateToProps)(Record);</code></pre>

<p>
  The full code is in <code>/routes/Records/routes/Record.js</code>.
</p>

<h2>A solution</h2>
<p>
  As I mentioned earlier, this is a common need in React/Redux projects for
  different reasons. I’ve used different methods for accomplishing dynamic
  routes and other folks have different approaches. With that, this is <em>a</em>
  solution, not necessiarly <em>the</em> solution.
</p>
<p>
  If this is helpful and you use it as is or modify it to fit your needs, let
  me know. I’m sure this could be improved and I’d love to hear ways to do so.
</p>

{{> thanks-for-reading }}
